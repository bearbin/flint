contract Token {
  var owner: Address
  var balances: [Address: Int]

  var decimals: Int
  var totalSupply: Int
  
  var Transfer: Event<Address, Address, Int> // from, to, value
  var Approval: Event<Address, Address, Int> // owner, spender, value
}

Token :: (owner) {
  public mutating func mint(destination: Address, value: Int) {
    balances[destination] = balances[destination] + value
  }

  public mutating func transferFrom(origin: Address, destination: Address, amount: Int) -> Bool {
    return processTransfer(origin, destination, amount)
  }
}

Token :: caller <- (any) {
  public func totalSupply() -> Int {
    return totalSupply
  }

  public func balanceOf(account: Address) -> Int {
    return balances[account]
  }

  public func getBalance() -> Int {
    return balances[caller]
  }

  public mutating func transfer(destination: Address, amount: Int) -> Bool {
    return processTransfer(caller, destination, amount)
  }

  mutating func processTransfer(origin: Address, destination: Address, amount: Int) -> Bool {
    if (balances[origin] < amount) {
      return false
    }

    if (balances[origin] - amount > balances[origin]) {
      return false
    }

    if (balances[destination] + amount < balances[destination]) {
      return false
    }

    balances[origin] -= amount
    balances[destination] += amount
    return true
  }
}
